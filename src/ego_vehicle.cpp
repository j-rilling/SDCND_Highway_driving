#include "ego_vehicle.h"

ego_vehicle::ego_vehicle() {
    CURRENT_CYCLE = 0;
}

ego_vehicle::~ego_vehicle() {

}

// This is a test method in order to test the comunication with the simulator
vector<vector<double>> ego_vehicle::getCircularTraj(double x0, double y0, double th0, double v0, 
        const vector<double> &previousXpoints, const vector<double> &previousYpoints) {
    CURRENT_CYCLE = (CURRENT_CYCLE+1)%UPDATE_RATE;
    double start_x;
    double start_y;
    double start_theta;

    vector<double> next_x_vals;
    vector<double> next_y_vals;
    double path_size = previousXpoints.size();
    if (CURRENT_CYCLE == 1) {
        if (path_size == 0) {
            start_x = x0;
            start_y = y0;
            start_theta = deg2rad(th0);
        }
        else {
            start_x = previousXpoints[path_size -1];
            start_y = previousYpoints[path_size -1];

            double start_x2 = previousXpoints[path_size - 2];
            double start_y2 = previousYpoints[path_size - 2];
            start_theta = atan2(start_y - start_y2, start_x - start_x2); 
            for (unsigned int i = 0; i < path_size; i++) {
                next_x_vals.push_back(previousXpoints[i]);
                next_y_vals.push_back(previousYpoints[i]);
            }
        }

        double dist_inc = 0.5;
        double pos_x = start_x;
        double pos_y = start_y;
        for (unsigned int i = 0; i < 50 - path_size; i++) {
            next_x_vals.push_back(pos_x + dist_inc*cos(start_theta+(i+1)*(pi()/100)));
            next_y_vals.push_back(pos_y + dist_inc*sin(start_theta+(i+1)*(pi()/100)));
            pos_x += dist_inc*cos(start_theta+(i+1)*(pi()/100));
            pos_y += dist_inc*sin(start_theta+(i+1)*(pi()/100));
        }
        return {next_x_vals, next_y_vals};
    } 
    else {
        return {previousXpoints, previousYpoints};
    }
}

vector<vector<double>> ego_vehicle::keepLineTraj(double x0, double y0, double th0, double v0, 
        const vector<double> &previousXpoints, const vector<double> &previousYpoints, 
        const vector<double> &mapsX, const vector<double> &mapsY) {
    CURRENT_CYCLE = (CURRENT_CYCLE+1)%UPDATE_RATE;
    double start_x, start_y, start_theta, start_s, start_s_v, start_s_acc;

    double dt = 0.020; // Every simulator cycle is 20ms long, so the position points are
                       // separated 20ms apart.


    vector<double> next_x_vals;
    vector<double> next_y_vals;
    double path_size = previousXpoints.size();
    if (CURRENT_CYCLE == 1) {
        if (path_size == 0) {
            start_x = x0;
            start_y = y0;
            start_theta = deg2rad(th0);
            // If there are no points on the last trajectory, it is assumed that the speed on s
            // is equal to v0 and the acceleration is equal to 0
            start_s_v = v0; 
            start_s_acc = 0;
        }
        return {next_x_vals, next_y_vals};
    }
    else {
        return {previousXpoints, previousYpoints};
    }
}

// This method gets the yaw values of a trajectory in XY. These values are needed in order to transform this 
// trajectory in XY to Frenet coordinates. The method was tested getting a lot of points in a circular 
// trajectory generated by "getCircularTraj", so the thetas of this trajectory are continuous between -pi/2 and pi/2.
// The expected result was obtained on the test.
vector<double> ego_vehicle::getThetasFromXY(const vector<double> &xPoints, const vector<double> &yPoints) {
    unsigned int points_length = xPoints.size();
    vector<double> thetaValues;
    for (unsigned int i = points_length - 1; i > 0; i--) {
        thetaValues.push_back(atan2(yPoints[i] - yPoints[i-1], xPoints[i] - xPoints[i-1]));
    }
    // For the theta of the first pair, the theta of the second pair is used
    thetaValues.push_back(atan2(yPoints[1] - yPoints[0], xPoints[1] - xPoints[0]));
    std::reverse(thetaValues.begin(), thetaValues.end());

    return thetaValues;
}

// This method converts a trajectory in XY coordinates to Frenet coordinates.
vector<vector<double>> ego_vehicle::trajXYToFrenet(const vector<double> &xPoints, const vector<double> &yPoints, 
    const vector<double> &thPoints, const vector<double> &mapsX, const vector<double> &mapsY) {
    vector<double> s_points;
    vector<double> d_points;
    for (unsigned int i = 0; i < xPoints.size(); i++) {
        vector<double> current_sd_point;
        current_sd_point = getFrenet(xPoints[i], yPoints[i], thPoints[i], mapsX, mapsY);
        s_points.push_back(current_sd_point[0]);
        d_points.push_back(current_sd_point[1]);
    }
    return {s_points, d_points};
}

vector<vector<double>> ego_vehicle::trajFrenetToXY(const vector<double> &sPoints, const vector<double> &dPoints,
        const vector<double> &mapsS, const vector<double> &mapsX, const vector<double> &mapsY) {
    vector<double> x_points;
    vector<double> y_points;
    for (unsigned int i = 0; i < sPoints.size(); i++) {
        vector<double> current_xy_point;
        current_xy_point = getXY(sPoints[i], dPoints[i], mapsS, mapsX, mapsY);
        x_points.push_back(current_xy_point[0]);
        y_points.push_back(current_xy_point[1]);
    }
    return {x_points, y_points};
}