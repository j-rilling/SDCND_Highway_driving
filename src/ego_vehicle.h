#ifndef _EGO_VEHICLE_H_
#define _EGO_VEHICLE_H_

#include "helpers.h"
#include <iostream>
#include <vector>
#include <map>
#include <cmath>
#include "spline.h"

using std::vector;

// Data structure used to put together all important variables
// defining a trajectory.
struct trajectoryInfo {
        unsigned int start_lane;
        unsigned int intended_lane;
        unsigned int final_lane;
        double start_s;
        double end_s;
        double velocity;
        double acceleration;
        string state;
};  

class ego_vehicle {
  public:
    /////////// CONSTRUCTOR AND DESTRUCTOR /////////////
    ego_vehicle();
    ~ego_vehicle();

    ////////////// TRAJECTORY GENERATION ///////////////
    // This is a test method in order to test the comunication with the simulator
    vector<vector<double>> getCircularTraj(double x0, double y0, double th0, double v0, 
        const vector<double> &previousXpoints, const vector<double> &previousYpoints);

    // This method transforms the trajectory data generated by the finite state machine into a smooth
    // "continuous" trajectory which is given to the simulator as vectors of points. 
    // In order to do that, the spline library of Tino Kluge was used.  
    vector<vector<double>> GetNewPosPoints(double x0, double y0, double th0, 
        const vector<double> &previousXpoints, const vector<double> &previousYpoints, 
        const vector<double> &mapsS, const vector<double> &mapsX, const vector<double> &mapsY);

    // This method is responsible of the changing on the trajectory. It uses a finite state machine
    // to determine what actions the ego vehicle should take on the next cycle.
    void updateTrajectory(const vector<double> &previousXpoints, double s0, double endPathS, const vector<vector<double>> &otherCars);

    // Returns true if a vehicle is found ahead of the ego vehicle, false otherwise
    // The found vehicle is passed as reference through "vehicleFound"
    bool getVehicleAhead(const vector<vector<double>> &otherVehicles, unsigned int lane, vector<double> &vehicleFound);

    // Returns true if a vehicle is found behind of the ego vehicle, false otherwise
    // The found vehicle is passed as reference through "vehicleFound" 
    bool getVehicleBehind(const vector<vector<double>> &otherVehicles, unsigned int lane, vector<double> &vehicleFound);

    // Gets the next timestep velocity and acceleration of a given lane. 
    // It chooses the minimum velocity and acceleration given other vehicle positions and accel/velocity constraints.
    vector<double> getKinematicsOfLane(const vector<vector<double>> &otherVehicles, unsigned int lane);

    // Method for trajectory generation for state "keep lane (KL)". It simply keeps the current velocity, acceleration
    // and lane for the next cycle.
    trajectoryInfo keepLaneTraj(double lastPathSize, const vector<vector<double>> &otherVehicles);

    // Method for trajectory generation for states "Prepare lane change left (PLCL)" and "Prepare lane change right (PLCR)"
    // On this state the ego vehicle takes the speed and acceleration of the lane it wants to change, but that only if this 
    // speed is slower than the one of the current lane, so the vehicle in front of the ego vehicle does not get hit.
    // Also if a vehicle behind is detected the current speed and acceleration are kept so the vehicle behind don't crash
    // with the ego vehicle.
    trajectoryInfo prepLaneChangeTraj(string state, double lastPathSize, const vector<vector<double>> &otherVehicles);

    // Method for trajectory generation for states "Lane change left (LCL)" and "Lane change right (PLCR)". It checks for vehicles 
    // ahead and behind in a range given by "SEARCH_RANGE". If a vehicle is found, the velocity and acceleration take the value 0
    // so this trajectory is always rejected when calculating the lowest cost. If no car in the range is found, the lane is 
    // changed and the velocity and acceleration of the new lane are taken.
    trajectoryInfo laneChangeTraj(string state, double lastPathSize, const vector<vector<double>> &otherVehicles);

    ////////////// FINITE STATE MACHINE ///////////////
    // Selects the correct trajectory generation method based on a given FSM state. This method is called by "chooseNewState".
    trajectoryInfo generateStateTraj(string state, double lastPathSize, const vector<vector<double>> &otherVehicles);

    // Returns a vector with all the possible next FSM states based on the current state. This method is called by "chooseNewState".
    vector<string> possibleNextStates();
    
    // Gets a cost based on the average speed of the intended lane and the final lanes. If the speed of the intended
    // and/or the final lane are smaller than the target speed, a higher cost is returned.    
    double avgLaneSpeedCost(trajectoryInfo trajectory, const vector<vector<double>> &otherVehicles); 

    // Gets a cost based on the speed of the closest vehicle ahead on the intended and final lanes. If there is not a car
    // close at one of those lanes, the returned speed is replaced by the target speed. If there is a slow car at the 
    // intended or the final lane, the cost will be higher.
    double NextCarOnLaneSpeedCost(trajectoryInfo trajectory, const vector<vector<double>> &otherVehicles); 

    // Gets a cost based on the distance to the closest vehicle on the intended and final lanes. If the distance of one or
    // both of them is small, a high cost is returned and viceversa.
    double NextCarOnLaneDistCost(trajectoryInfo trajectory, const vector<vector<double>> &otherVehicles); 

    // Gets a cost based on the distance to the fastest lane, so it is easier for the ego vehicle to move 
    // to a lane without vehicles ahead in the case where that lane is 2 lanes away of the current lane. So it works 
    // complementing the cost function "avgLaneSpeedCost" which only decides between the current and the next lane.
    double distFromFastestLaneCost(trajectoryInfo trajectory, const vector<vector<double>> &otherVehicles);

    // This cost function avoids lane changes when the speed of the car is extremely low 
    // (like at the beginning of the simulation for example).
    double laneChangeWhenSlowCost(trajectoryInfo trajectory, const vector<vector<double>> &otherVehicles);

    // This cost function avoids unnecessary lane changes when the cost of staying at the lane or changing is 
    // exactly the same. It is the cost function with the lowest cost, since this cost function is kind of a threshold 
    // cost which needs to be smaller than the cost of changing to another lane when the change is really meaningfull,
    double laneChangeCost(trajectoryInfo trajectory, const vector<vector<double>> &otherVehicles); 

    // This cost function should avoid lane changes when the ego vehicle is too close to the next vehicle on the same
    // lane. Thisis in order to avoid crashing with it because after changing to state "LSL" or "LSR" the ego vehicle 
    // takes the velocity and acceleration of the new lane, which happens before the ego vehicle is completely on the 
    // new lane.
    double laneChangeWhenNextCarCloseCost(trajectoryInfo trajectory, const vector<vector<double>> &otherVehicles); 

    // Method that determines the average speed of a given lane. For that, it uses the speed of the vehicles 
    // until 5 times the normal SEARCH_RANGE ahead of the ego vehicle.
    double getLaneAvgSpeed(const vector<vector<double>> &otherVehicles, unsigned int lane); //

    // Function that determines the speed of the closest vehicle ahead on the given lane. It looks for vehicles
    // until 1 time SEARCH_RANGE ahead of the ego vehicle. If no car is found -100.0 is returned.
    double getNextCarOnLaneSpeed(const vector<vector<double>> &otherVehicles, unsigned int lane); 

    // Function that determines the distance to the closest vehicle ahead on the given lane. It looks for vehicles
    // until 1 time SEARCH_RANGE ahead of the ego vehicle. If no car is found 
    // SEARCH_ENGINE + TRAJ_LENGTH*TIME_STEP*current_speed_xy is returned, which corresponds to the highest distance
    // that this method can measure.
    double getNextCarOnLaneDist(const vector<vector<double>> &otherVehicles, unsigned int lane);

    // This method takes all the cost function results multiplied by their weights and sums them up to get the
    // total cost.
    double getTotalCost(trajectoryInfo trajectory, const vector<vector<double>> &otherVehicles, bool verbose);

    // Select new FSM state and returns the corresponding trajectory
    trajectoryInfo chooseNewState(double lastPathSize, const vector<vector<double>> &otherVehicles, bool verbose);


  private:
    ////////////// CONSTANTS (GENERAL) ///////////////
    const double TIME_STEP = 0.020; // Every simulator cycle is 20ms long, so the position points are
                                    // separated 20ms apart.
    const unsigned int TRAJ_LENGTH = 50;   // The standard generated trajectory has 100 points.
    const double SPEED_LIMIT = 22.0;        // The speed limit is the end speed value used in order to generate trajectories
                                            // This value is in m/s and is equal to 49.2126 MPH.
    const double DISTANCE_BUFFER = 30.0;    // Corresponds to a distance buffer it should be keeped with the next vehicle 
                                            // on the lane.
    const double SEARCH_RANGE = 10.0;       // Corresponds to the distance within a vehicle ahead or behind is searched.
    const double LANE_WIDTH = 4.0;      // Width of the lanes in meters.

    const double MAX_ACCEL = 10.0;      // Maximum acceleration of the ego vehicle in m/s^2
    const double MAX_JERK = 10.0;       // Maximum jerk of the ego vehicle in m/s^3

    std::map<string, int> LANE_DIRECTION = {{"PLCL0", -1}, {"PLCR0", 1},
                                                  {"PLCL1", -1}, {"PLCR1", 1}, 
                                                  {"PLCL2", -1}, {"PLCR2", 1},
                                                  {"PLCL3", -1}, {"PLCR3", 1},
                                                  {"PLCL4", -1}, {"PLCR4", 1},
                                                  {"PLCL5", -1}, {"PLCR5", 1},
                                                  {"PLCL6", -1}, {"PLCR6", 1},
                                                  {"PLCL7", -1}, {"PLCR7", 1},
                                                  {"PLCL8", -1}, {"PLCR8", 1},
                                                  {"PLCL9", -1}, {"PLCR9", 1},
                                                  {"LCL", -1}, {"LCR", 1}
                                                 };

    ////////////// CONSTANTS (WEIGHTS) ///////////////
    const double WEIGHT_AVG_LANE_SPEED = 3000.0;    // Weight of cost function "avgLaneSpeedCost".
    const double WEIGHT_NEXT_CAR_ON_LANE_SPEED = 500.0;     // Weight of cost function "NextCarOnLaneSpeedCost".
    const double WEIGHT_NEXT_CAR_ON_LANE_DIST = 800.0;      // Weight of cost function "NextCarOnLaneDistCost".
    const double WEIGHT_DIST_FASTEST_LANE = 1500.0;     // Weight of cost function "distFromFastestLaneCost"
    const double WEIGHT_LANE_CHANGE_WHEN_SLOW = 4500.0;     // Weight of cost function "laneChangeWhenSlowCost"
    const double WEIGHT_LANE_CHANGE_NORMAL = 400.0;     // Weight of cost function "laneChangeCost"
    const double WEIGHT_LANE_CHANGE_WHEN_CLOSE_NEXT_CAR = 0.0;      // Weight of cost function "laneChangeWhenNextCarCloseCost"

    /////////////////// VARIABLES ////////////////////
    unsigned int lanes_quantity;    // Quantity of lanes of the street currently being used 
    int current_lane;               // Current lane of the ego vehicle on the street.
    double current_pos_s;           // Current Frenet s position of the ego vehicle (in m).
    double target_speed_xy;         // Speed the ego vehicle must drive if possible (in m/s).
    double current_speed_xy;        // Current speed of the ego vehicle (in m/s).
    double current_acc_xy;          // Current acceleration of the ego vehicle (in m/s^2).
    string current_FSM_state;       // Current state of the finite state machine used to control the ego vehicle.

};

// This definition of type is used by "getTotalCost" in order to make a list of all the cost functions which are
// executed within a for loop.
typedef double (ego_vehicle::*costFunction_ego) (trajectoryInfo trajectory, const vector<vector<double>> &otherVehicles);

#endif // _EGO_VEHICLE_H_